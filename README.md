# MIPS-Final
Everything for my MIPS final project, Breakout.

To run, you need to download Mars4_5# and run the LFP3_jah1145.asm in it. You also need the ball.jpg, image.bmp, and panda.jpg files. You need to change the file paths in the top .data portion of the LFP3 code so that the file paths to these images are correct for your computer. You need to run the file with the bitmap display open, configured to 1, 1, 512, 256, and the heap, as well as the keyboard and and display MMIO simulator.
A and D move the paddle left and right, respectively, while W will release the ball from the paddle.

For Mars4.5#:
  This is an attempt to enable sprites with the Mars bitmap display. The result is three new syscalls (60-62) for Mars that allow a sprite to be displayed on the bitmap display. Syscall 60 “OpenImage” takes the address of an .asciiz with the file location of an image of any type (.jpg, .bmp, etc) and creates a representation of the image. Syscall 61 “WriteImage” takes in an x and y location to place the image at on the bitmap display. Syscall 62 “CloseImage” internally sets the image to null so it will no longer be displayed.
  Simply run Mars4_5# and you may use the new syscalls. Please note that any changes to the sprite graphics via the syscalls won’t take effect until the next call to update a memory address of the bitmap display. I recommend drawing a single dot somewhere on the screen after any of the syscalls to make the changes immediate.
  When you call syscall 60, with the address of an .asciiz that contains the image file location in $a0, this sets the image (as a BufferedImage) to a variable “image” in a static class “sprite” inside of the BitmapDisplay class. It also sets a Boolean imageFlag to true. On the next MIPS graphics (graphics controlled by memory address) update, the BitmapDisplay’s update function will check the flag, and since it’s true, call produceSprite() inside the grid class (also an internal class to the BitmapDisplay class). This function sets a spriteGrid variable (a two dimensional array of Colors) to a representation of the image. Combine() is also called, which takes the spriteGrid and places it at the current x, y coordinate (default 0,0) in a comboGrid, which is a copy of the origGrid (a representation of the MIPS graphics at any point). The BitmapDisplay displays a representation of the comboGrid in MARS.
  When you call syscall 61 (with the x location in $a0 and the y in $a1), the current x and y are saved to variables oldX and oldY, while x and y are set to the arguments passed in. A moveFlag is set to true, which again triggers functions when the next update to MIPS graphics is called. A function resetSprite resets the origGrid over the comboGrid at the oldX,old coordinates. Then the combine function is called again, writing the sprite at the new x,y location in the comboGrid. If the sprite extends beyond the size of the display for any reason, as much as can fit will be written and no more. 
  Syscall 62 sets the sprite.image variable to null and the imageFlag to true, removing the image on the next update to MIPS graphics.
  Every time MIPS graphics is updated, it’s updated to both the origGrid and the comboGrid, ensuring that MIPS graphics can be written over the sprite, and any MIPS graphics that occur in between syscall 61 calls will be maintained.
